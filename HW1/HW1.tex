\documentclass[11pt]{article}
\usepackage{../EllioStyle}

\title{Homework 1}
\author{Elliott Pryor}
\date{24 Jan 2021}

\rhead{Homework 1}
\lhead{Elliott Pryor}


\makeatletter
\def\mathcolor#1#{\@mathcolor{#1}}
\def\@mathcolor#1#2#3{%
  \protect\leavevmode
  \begingroup
    \color#1{#2}#3%
  \endgroup
}
\makeatother

\begin{document}
\maketitle

\problem{1}
% Copy from Millman tex source when posted
\hrule

Some sort of binary search. 

Jointly search P and P'
Pick $a \in P, \sp b \in P'$
Want line with highest z intercept

Idea: O(n) run Grahm's Scan on it. Already sorted so takes O(n) time.

Idea: Start at $a$ compute point $b \in P'$ tangent to $a$ (O (log n)). 
Then reverse, find $a$ tangent to $b$. Then forward, find $b$ tangent to $a$. Then done????

\begin{algorithm}
    \caption{Tangent Function}\label{guests}
    \label{alg:prob1}
    \begin{algorithmic}[1]
    \Function{Tangent}{$a, P$}
        \State Binary search to find point of tangency
        \State $low \gets 0$
        \State $high \gets |P|$
        \While{!found}
            \State $m \gets \lceil (low + high)/2 \rceil$
            \State $line \gets \overrightarrow{a,m}$
            \If{$line([m + 1]_x) > [m + 1]_y$ and $line([m - 1]_x) > [m - 1]_y$  }
                \State found it (is supporting line)
                \State \textbf{return} m
            \ElsIf{$line([m + 1]_x) > [m + 1]_y$}
                \State line intersects some point before m (tangent point to left)
                \State $high \gets m - 1$
            \ElsIf{$line([m - 1]_x) > [m - 1]_y$}
                \State line intersects some point after m (tangent point to right)
                \State $low \gets m + 1$
            \EndIf
        \EndWhile
    \EndFunction
    \end{algorithmic}

    \begin{algorithmic}[1]
        \Function{UpperTangent}{$P, P'$}
            \State Run Tangent 3 times to find upper tangent.
            \State $a \gets |P|/2$ \quad // Random point in $P$
            \State $b \gets Tangent(a, P')$ \quad // So we can 'see' $p_i$ from $b$
            \State $a \gets Tangent(b, P)$ \quad // Finds $p_i$
            \State $b \gets Tangent(a, P')$ \quad // Finds $p_j$
            \State \textbf{return} $\overrightarrow{a,b}$
        \EndFunction
        \end{algorithmic}

\end{algorithm}












\problem{2}

\hrule

\begin{enumerate}[1. ]
    \item The points on the $Pareto(P)$ fall on a series of horizontal and vertical line segments.
    It follows a line in 'Manhattan' distance. In order to make the analogous assertion,
    we define corner $C(p)$ $p \in P$ as the region $(x,y) \in \reals ^2 \sp x \leq p_x, \sp y \leq p_y$.
    

    Then a point $p$ is on the Pareto of a set $P$ if and only if
    there is no other corner $C(p'), \sp p \neq p'$, containing $p$

    \item 
    This is almost identical to Grahm's Scan. We replace the Orient() function with a different comparison.
    We simply compare the $y$ values of adjacent points. Since the points are in sorted, $x$, order
    if a a point $p_i$ has a larger y-coordinate than $p_{i-1}$ the $p_{i-1}$ would be in $C(p_i)$ so is not on the Pareto.
    Since this comparison only needs the first point in the stack, we also adjust initialization of $S$
    to only push $p_1$ onto the stack, and to not terminate the while loop unless there are $0$ points in the stack.
    
    This has the same running time as Grahm's Scam. Since after sorting, the algorithm takes a linear pass through
    all of the points. It also only pops a point at most once from the stack. The only difference with this algorithm
    from Grahm's Scan is the Orient. Since comparing y-coordinates is also a constant time lookup, our running time is $O(n log(n))$
    due to the sorting in line 2.
    \begin{algorithm}
        \caption{Pareto Scan}\label{guests}
        \begin{algorithmic}[1]
        \Function{ParetoScan}{$P$}
            \State sort $P$ by increasing $x$ value
            \State push $p_1$ onto stack $S$
            \For{$i \gets 3,..., n$}
                \While{$|S| \geq 1$ and $p_{i,y} \geq S[top]_y$}
                    \State pop $S$
                \EndWhile
                \State push $p_i$ onto $S$
            \EndFor
        \EndFunction
        \end{algorithmic}
    \end{algorithm}

    \item Our modified Jarvis march algorithm would search for the point with the greatest $y$ value.
    Then it would loop and search for the point with the next greatest y-coordinate to the right of the previous point ($p_{i,x} > p_{i-1,x}$).
    This loop is repeated $h - 1$ times (the first point was found in initialization step of finding point with largest y-coordinate).

    \begin{algorithm}
        \caption{Jarvis Stairs}\label{guests}
        \begin{algorithmic}[1]
        \Function{JarvisStairs}{$P$}
            \State find point $p_1$ with largest y-coordinate
            \State $S \gets p_1$
            \For{$i \gets 2,..., h$}
                \State find point $p_i$ with largest y-coordinate such that $p_{i,x} > p_{i-1,x}$
            \EndFor
            \State \textbf{return} S
        \EndFunction
        \end{algorithmic}
    \end{algorithm}

\end{enumerate}





\problem{3}

We say $Orient(a,b,c) > 0$ if it is oriented counter clockwise (makes left turn), and $Orient(a,b,c) < 0$ if it is oriented clockwise (right turn)

\begin{algorithm}
    \caption{Tangent Function}\label{guests}
    \label{alg:prob1}
    \begin{algorithmic}[1]
    \Function{Tangent}{$a, P$}
        \State Binary search to find point of tangency
        \State $low \gets 0$
        \State $high \gets |P|$
        \State $p_1$, $p_2$
        \While{!found}
            \State $c \gets \lceil (low + high)/2 \rceil$
            \State $b \gets c-1, \sp d \gets c + 1$ \quad b is point counter-clockwise from a, d is point clockwise from a
            \If{$Orient(a, c, b) = Orient(a, c, d)$}
                \State found tangent
                \State $p_1 \gets m$
                \State \textbf{break while}
            \ElsIf{$Orient(a,c,b) > 0$ and $Orient(a,c,d) < 0$}
                \State Need to move search point left (counter-clockwise)
                \State $high \gets b$
            \ElsIf{$Orient(a,c,b) < 0$ and $Orient(a,c,d > 0)$}
                \State need to move search point right (clockwise)
                \State $low \gets d$
            \EndIf
        \EndWhile

        \State Repeat same while loop but flipping inequality signs to find other tangency point.
        \State \textbf{return} $p_1, p_2$
    \EndFunction
    \end{algorithmic}
\end{algorithm}



\end{document}